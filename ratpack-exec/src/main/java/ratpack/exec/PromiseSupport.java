/*
 * Copyright 2020 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package ratpack.exec;

import io.netty.channel.EventLoop;
import ratpack.exec.api.Blocks;
import ratpack.exec.internal.DefaultExecution;
import ratpack.exec.internal.ExecThreadBinding;
import ratpack.func.BiFunction;
import ratpack.func.Factory;

import java.util.Iterator;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.Executor;
import java.util.concurrent.atomic.AtomicReference;
import java.util.function.Supplier;

/**
 * Support utilities for binding execution segment processing to specific executors.
 *
 * @since 2.0.0
 */
public class PromiseSupport {

  private PromiseSupport() {
  }

  /**
   * Execute the provide factory on the blocking executor bound to the provided type.
   * <p>
   * The execution segment represented by the factory is off-loaded to the specified binding if it exists.
   * The result from the segment is then handed back to the initiating segment (i.e. the continuation).
   * <p>
   * The initial execution of this segment is always from the event loop of the originating execution.
   *
   * @param executionType the type binding for the destination blocking executor
   * @param factory a function which generates the value for the execution segment
   * @param <E> an enum that also implements {@link ExecutionType} for type safety
   * @param <T> the type of the return value generated by this segment
   * @return an upstream which generates the value within the promise chain
   */
  public static <E extends Enum<E> & ExecutionType, T> Upstream<T> executeOn(E executionType, Factory<T> factory) {
    return delimitOn(executionType, ExecController::getExecutorService, factory);
  }

  /**
   * Execute the provide factory on the non-blocking executor bound to the provided type.
   * <p>
   * The execution segment represented by the factory is off-loaded to the specified binding if it exists.
   * The result from the segment is then handed back to the initiating segment (i.e. the continuation).
   * <p>
   * The initial execution of this segment is always from the event loop of the originating execution.
   *
   * @param executionType the type binding for the destination non-blocking executor
   * @param factory a function which generates the value for the execution segment
   * @param <E> an enum that also implements {@link ExecutionType} for type safety
   * @param <T> the type of the return value generated by this segment
   * @return an upstream which generates the value within the promise chain
   */
  public static <E extends Enum<E> & ExecutionType, T> Upstream<T> nonBlockingExecuteOn(E executionType, Factory<T> factory) {
    return delimitOn(executionType, ExecController::getEventLoopGroup, factory);
  }

  private static <E extends Enum<E> & ExecutionType, T> Upstream<T> delimitOn(E executionType, BiFunction<ExecController, E, Executor> executorFactory, Factory<T> factory) {
    return downstream -> {
      DefaultExecution execution = DefaultExecution.require();
      EventLoop eventLoop = execution.getEventLoop();
      Executor executor = executorFactory.apply(execution.getController(), executionType);

      execution.delimit(downstream::error, continuation ->
        eventLoop.execute(() ->
          CompletableFuture.supplyAsync(
            new Supplier<Result<T>>() {
              Result<T> result;

              @Override
              public Result<T> get() {
                try {
                  execution.bindToThread();
                  intercept(execution, execution.getAllInterceptors().iterator(), () -> {
                    try {
                      result = Result.success(factory.create());
                    } catch (Throwable e) {
                      result = Result.error(e);
                    }
                  });
                  return result;
                } catch (Throwable e) {
                  DefaultExecution.interceptorError(e);
                  return result;
                } finally {
                  execution.unbindFromThread();
                }
              }
            }, executor
          ).thenAcceptAsync(v -> continuation.resume(() -> downstream.accept(v)), eventLoop)
        )
      );
    };
  }

  /**
   * Utility method for resolving a promise value by awaiting for the value from the provided promise.
   * This requires the caller to specify the expected thread binding for the current segment to initiate the resolution.
   * Calling this method from a segment bound to any other thread binding will result in an exception as it would lead
   * to deadlock or significant performance impacts.
   * <p>
   * Resolution is executed by using a latch to block further execution of this segment until the value from the promise
   * is available.
   *
   * @param executionType the required thread binding for the calling segment
   * @param message the error message to emit if called from a segment on a different thread binding
   * @param promise the promise to await value resolution
   * @param <E> the execution type
   * @param <T> the type of the promised value
   * @return the resolved value from the promise
   * @throws Exception if called from an execution segment bound to a type other than the specified type
   */
  @Blocks
  public static <E extends Enum<E> & ExecutionType, T> T awaitOn(E executionType, String message, Promise<T> promise) throws Exception {
    ExecThreadBinding.requireThread(executionType, message);
    DefaultExecution execution = DefaultExecution.require();
    CountDownLatch latch = new CountDownLatch(1);
    AtomicReference<Result<T>> resultReference = new AtomicReference<>();

    execution.delimit(t -> {
        resultReference.set(Result.error(t));
        latch.countDown();
      }, continuation ->
        promise.connect(
          new Downstream<T>() {
            @Override
            public void success(T value) {
              unlatch(Result.success(value));
            }

            @Override
            public void error(Throwable throwable) {
              unlatch(Result.error(throwable));
            }

            @Override
            public void complete() {
              unlatch(Result.success(null));
            }

            private void unlatch(Result<T> result) {
              continuation.resume(() ->
                execution.getEventLoop().execute(() -> {
                  resultReference.set(result);
                  latch.countDown();
                })
              );
            }
          }
        )
    );

    execution.eventLoopDrain();
    latch.await();
    return resultReference.get().getValueOrThrow();
  }

  public static void intercept(Execution execution, final Iterator<? extends ExecInterceptor> interceptors, Runnable runnable) throws Exception {
    if (interceptors.hasNext()) {
      interceptors.next().intercept(execution, ExecType.BLOCKING, () -> intercept(execution, interceptors, runnable));
    } else {
      runnable.run();
    }
  }
}
